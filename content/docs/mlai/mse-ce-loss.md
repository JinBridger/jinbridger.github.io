---
title: "推导均方差与交叉熵公式"
weight: 1
date: 2025-09-07
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

# 推导均方差与交叉熵公式

## 均方差

均方差常用于连续值的预测, 例如回归类任务.
这里记录一下从极大似然估计推导均方差的过程.

假设要估计的函数为 $f(x)$.
我们从这个函数上采样了一些点 $\\{(x_1, y_1), (x_2, y_2), ..., (x_n, y_n)\\}$.
由于采样不可能完全精准, 假设采样有误差 $\varepsilon$, 也就是 $$y_i = f(x_i)+\varepsilon_i$$
其中误差满足正态分布 $$\varepsilon \sim \mathcal{N}(0, \sigma^2)$$
假设我们采样的时候对于一个固定的采样点 $x_i$ , 将采样值建模为随机变量 $Y$ .
那么 $Y$ 的分布为 $$P(Y|x_i, f, \sigma^2) = p(Y=y|x_i, f, \sigma^2) = \frac{1}{\sqrt{2\pi\sigma^2}} \exp (-\frac{(y - f(x_i))^2}{2\sigma^2}) $$
$Y$ 取到 $y_i$ 的概率为 $$p(Y=y_i|x_i, f, \sigma^2) = \frac{1}{\sqrt{2\pi\sigma^2}} \exp (-\frac{(y_i - f(x_i))^2}{2\sigma^2})$$
我们将采样视作是实验, 采样结果就是实验结果, 基于这些采样结果的似然函数可以表示为
$$L(f, \sigma^2) = \prod_{i=1}^n p(Y=y_i|x_i, f, \sigma^2) $$

> [!TIP]
> 似然函数简单来说就是**从实验结果反推实验对象**, 即「要估计的实验对象应该长什么样子才能使得出现实验结果的概率最大」. 这里要估计的实验对象就是 $f$. 而采样结果就是实验结果. 我们认为不同的采样结果之间是相互独立的, 因此用其概率的乘积来表示出现这个实验结果的概率. 我们要寻找的就是让这个实验结果出现的概率最大的 $f$.
>
> 这里由于 $\sigma^2$ 同样也是未知的, 因此我们也写到似然函数的参数里面. 我们并不关心 $\sigma^2$ 是多少, 我们只知道它是个常数.

我们的目标就是找到让似然函数取到最大值的 $f$, 即寻找
$$\argmax_f L(f, \sigma^2)$$

对于乘积, 求取极值点的方法一般是先取对数:
$$
\begin{aligned}
\log L(f, \sigma^2) &= \sum_{i=1}^n \log p(Y=y_i|x_i, f, \sigma^2)\\\\
&= \sum_{i=1}^n (-\frac{1}{2}\log (2\pi \sigma^2) -\frac{(y_i - f(x_i))^2}{2\sigma^2})
\end{aligned}
$$

由于我们认为 $\sigma^2$ 是个常数, 因此为了让这个式子能取到最大值, 我们就要让后一项的分子尽量取最小值. 也就是求满足下式的 $f$
$$\argmin_f \sum_{i=1}^n (y_i - f(x_i))^2$$

方差出现了. 但是距离均方差还有一个 $\dfrac{1}{n}$. 这个 $\dfrac{1}{n}$ 可以看作是一个归一化系数, 使得用损失函数计算步长的时候只会受学习率的影响, 而不会受到采样数量 (可以认为是 batch size) 的影响.

因此损失函数就是:
$$\mathcal{L} = \frac{1}{n} \sum_{i=1}^n (y_i - f(x_i))^2$$

## 交叉熵

交叉熵常用于离散值的预测, 例如分类任务.

信息论中, 交叉熵的定义如下: (推导过程见[信息论入门笔记]({{< ref "/docs/mlai/information-theory-basic.md" >}}))

假设我们有两个针对同一个随机变量的不同分布 $P$ 与 $Q$, 那么定义 $P$ 与 $Q$ 的交叉熵为
$$H(P, Q) = -\sum_{i=1}^n p(x_i)\log q(x_i)$$


在分类任务中, 真正的分布就是 $P$, 模型当前预测的分布就是 $Q$. 展开来说, 假如分类的类别有 $n$ 类, 对应的标签为 $y_1, y_2, ... y_n$. 我们希望找到一个函数 $f$, 使得对于所有可能的输入 $x$, 函数 $f(x)$ 都能输出正确的标签 $y$. 这个函数就是我们训练的模型.

我们拎出来一个输入 $x$ 来看, 假设 $x$ 对应的正确答案是 $y_k$. 函数输出的标签为随机变量 $Y$, 那么对于我们要找的正确的函数 $f$, 其输出标签 $Y$ 的分布 $P_{f}(Y|x)$ 为

$$
P_f(Y|x) =
p_f(Y=y_i|x) =
\begin{cases}
1 & \text{if } i = k \\\\
0 & \text{else }
\end{cases}
$$

我们并不知道函数 $f$ 应该长什么样子, 因此我们猜了一个函数 $f'$, 用这个函数去计算了对应的分布 $P_{f'}(Y|x)$, 也就是我们预测的输出.
$$P_{f'}(Y|x) = p_{f'}(Y=y_i|x)$$

机器学习的本质就是其实就是不断猜分布, 计算距离真正的分布还有多远, 然后尝试更新函数来减少距离.

现在我们猜完了分布, 下一步就是计算距离真正的分布还有多远. 根据前文所述, 这里我们就采用交叉熵来作为损失函数.

> [!IMPORTANT]
> 比起交叉熵, 相对熵在定义上更接近损失函数. 按理来说, 我们应该使用相对熵来计算 $P_{f'}(Y|x)$ 距离 $P_{f}(Y|x)$ 的距离. 但是我们实际上用的是交叉熵 $H(P_f, P_{f'})$ 而不是相对熵 $D_\text{KL}(P_f\parallel P_{f'})$ . 为什么？
> 
> 这是因为优化交叉熵 $H(P_f, P_{f'})$ 与优化相对熵 $D_\text{KL}(P_f\parallel P_{f'})$ 是一样的. 根据公式
>
> $$D_\text{KL}(P_f\parallel P_{f'}) = H(P_f, P_{f'}) - H(P_f)$$
>
> 由于真正的分布是 one-hot 编码, 因此 $H(P_f) = 0$. 因此在这种情况下, 交叉熵等于相对熵.
>
> 不过也有一些场景不能用交叉熵代替相对熵, 比如 VAE.

因此, 我们就得出了对于单个样本 $x$ 的损失函数:
$$\mathcal{L} = -\sum_{i=1}^n p_{f}(Y=y_i|x)\log p_{f'}(x)$$
其中
$$
p_f(Y=y_i|x) =
\begin{cases}
1 & \text{if } i = k \\\\
0 & \text{else }
\end{cases}
$$
